## RUST의 메모리 관리 (소유권)
`Javascript`는 가비지 컬렉터를 사용해서 메모리를 관리합니다.
`C언어`는 개발자가 직접 메모리를 할당하고 해제해줘야 합니다.

**`RUST`는 소유권이라는 새로운 접근법으로 메모리를 관리합니다.**

`RUST`에서 메모리는 **컴파일 타임**에 컴파일러가 체크할 규칙들로 구성된 소유권 시스템을 통해 관리됩니다.
때문에 소유권 기능의 어떤 것도 **런타임 비용이 발생하지 않습니다.**

---
## 스택과 힙
스택과 힙은 선입 선출이냐 선입 후출이냐의 차이 이외에도 담겨있는 모든 데이터가 고정된 크기를 가지고 있느냐, 그렇지 않느냐의 차이가 있습니다.

스택은 담겨있는 모든 데이터가 **고정된 크기를 가지고 있습니다.**

---
## 소유권 규칙
```
  1. 러스트의 각각의 값은 해당값의 오너(Owner)라 불리는 변수를 가진다.
  2. 한번에 딱 하나의 오너만 존재할 수 있다.
  3. 오너가 스코프 밖으로 벗어날때, 값은 버려진다(dropped).
```

---
## 변수의 스코프

스코프란 아이템이 유효한 범위입니다.

```rust
fn main() {
    let s = "hello"; // 이 변수는 main 함수 전역에서 유효합니다.

    {
        let _s = "hello"; // 이 변수는 여기서부터 유효하고
                          // 여기까지만 유효하며,
    }                     // 여기서부터 유효하지 않습니다.
}
```

## String 변수
위 예제에서 `s`와 `_s`는 모두 `스트링 리터럴`입니다. 스트링 리터럴은 프로그램 안에 하드코딩 되어있고, **불변한(Immutable)** 값입니다. 코드를 작성하는 시점에서 모든 문자열을 알 수는 없기 때문에 `Rust`는 2번째 문자열 타입인 `String`타입을 지원합니다. `String`타입은 힙에 할당되고 때문에 고정되지 않은 양의 텍스트를 저장할 수 있습니다.

그럼 왜 `String` 은 가변하지만 스트링 리터럴은 그렇지 않을까요? 그 이유는 두 타입이 메모리를 쓰는 방식에 있습니다.

## 메모리와 할당
스트링 리터럴은 텍스트가 최종 실행파일에 직접 하드코딩 되었고, 그렇기 때문에 빠르고 효율적입니다. 하지만 이는 텍스트가 변경되지 않는 것을 전제로 합니다.

`String` 타입은 변경 가능하고 커질수 있는 텍스트를 지원하기 위해 만들어진 타입입니다. 또한 우리는 힙에서 컴파일 시점에서는 알 수 없는 어느정도 크기의 메모리 공간을 할당받아 내용물을 저장할 필요가 있습니다.

즉,
1. 런타임에 운영체제로부터 메모리가 요청되어야 한다.
2. `String`의 사용이 끝났을 때 운영체제에게 메모리를 반납할 방법이 필요하다.

1번의 경우 `String::from`을 호출함으로써 개발자가 직접 구현 부분에서 필요한 만큼의 메모리를 요청합니다
이는 다른 언어들과 유사합니다.

2번의 경우 _(메모리를 반납하는 경우) 는 다른 언어들과 다릅니다.

가비지 컬렉터를 가지고 있는 경우, 가비지 컬렉터가 사용하지 않는 메모리를 계속 찾아서 지워주기 때문에 개발자들은 이런 생각을 안해도 됩니다.

가비지 컬렉터가 없으면 개발자가 직접 필요없는 메모리를 반납하는 코드를 작성해야 합니다. 

**러스트는 변수가 소속되어 있는 스코프 밖으로 벗어나는 순간 자동으로 반납됩니다.**

```rust
{
    let s = String::from("hello"); // 이 변수는 여기서부터 유효하고
                                    // 여기까지만 유효하며,
}                                   // 여기서부터 유효하지 않습니다.
```

`s`가 스코프 밖으로 벗어날 때 `String`이 요구한 메모리를 운영체제에게 반납합니다. 이 때 러스트는 `drop`이나는 함수를 호출합니다. 러스트는 중괄호가 닫힐때 자동적으로 `drop`을 호출합니다.

#### 변수와 데이터가 상호작용하는 방법: 이동(move)
```rust
let x = 5;
let y = x;
```
위 예제를 보았을때, 다른 언어들에서의 경험을 토대로 "정수값 `5`를 `x`에 묶어놓고, `x`값의 복사본을 만들어 `y`에 묶는다. 라고 추측할 수 있습니다. 